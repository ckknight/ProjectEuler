using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Ckknight.ProjectEuler.Collections;

namespace Ckknight.ProjectEuler.Problems
{
    [Problem(61,
        @"Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal
        numbers are all figurate (polygonal) numbers and are generated by the
        following formulae:

        Triangle          P3,n=n(n+1)/2   1, 3, 6, 10, 15, ...
        Square            P4,n=n2         1, 4, 9, 16, 25, ...
        Pentagonal        P5,n=n(3n-1)/2   1, 5, 12, 22, 35, ...
        Hexagonal         P6,n=n(2n-1)     1, 6, 15, 28, 45, ...
        Heptagonal        P7,n=n(5n-3)/2   1, 7, 18, 34, 55, ...
        Octagonal         P8,n=n(3n-2)     1, 8, 21, 40, 65, ...

        The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three
        interesting properties.

        1. The set is cyclic, in that the last two digits of each number is the
           first two digits of the next number (including the last number with
           the first).
        2. Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and
           pentagonal (P5,44=2882), is represented by a different number in the
           set.
        3. This is the only set of 4-digit numbers with this property.

        Find the sum of the only ordered set of six cyclic 4-digit numbers for
        which each polygonal type: triangle, square, pentagonal, hexagonal,
        heptagonal, and octagonal, is represented by a different number in the
        set.")]
    class Problem061 : BaseProblem
    {
        public override object CalculateResult()
        {
            var polygonalFuncs = new Func<int, int>[]
            {
                n => n * (n + 1) / 2,
                n => n * n,
                n => n * (3 * n - 1) / 2,
                n => n * (2 * n - 1),
                n => n * (5 * n - 3) / 2,
                n => n * (3 * n - 2),
            };

            var numbers = polygonalFuncs
                .SelectMany((f, i) => new Range(1, int.MaxValue)
                    .Select(n => f(n))
                    .SkipWhile(v => v < 1000)
                    .TakeWhile(v => v < 10000)
                    .Select(v => new
                    {
                        Part1 = v / 100,
                        Part2 = v % 100,
                        Value = v,
                        Type = i,
                    }))
                .ToArray();

            return new Range(5)
                .Aggregate(
                    numbers
                        .Where(n => n.Type == 0)
                        .Select(n => ImmutableSequence.Create(n)),
                    (acc, i) => acc
                        .SelectMany(x => numbers
                            .Where(n => n.Part1 == x.First().Part2)
                            .Where(n => x.All(v => n.Value != v.Value && n.Type != v.Type))
                            .Select(n => ImmutableSequence.Create(n, x))),
                    acc => acc
                        .Where(x => x.Last().Part1 == x.First().Part2))
                .Single()
                .Sum(x => x.Value);
        }
    }
}
